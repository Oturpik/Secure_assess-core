"""
Service for fetching CVE data from NVD and other sources.
"""

import aiohttp
import asyncio
from datetime import datetime, timedelta
import json
import logging
from typing import Dict, List, Optional

from src.config import settings

logger = logging.getLogger(__name__)

class CVEDataFetcher:
    """Service for fetching CVE data from various sources."""
    
    def __init__(self):
        self.nvd_api_key = settings.nvd_api_key
        self.nvd_base_url = settings.nvd_api_url
        self.headers = {
            'apiKey': self.nvd_api_key
        } if self.nvd_api_key else {}
    
    async def fetch_nvd_cves(self, 
                           start_date: Optional[datetime] = None,
                           end_date: Optional[datetime] = None) -> List[Dict]:
        """
        Fetch CVEs from NVD API within the specified date range.
        If no dates provided, fetches last 30 days by default.
        """
        if not start_date:
            start_date = datetime.utcnow() - timedelta(days=30)
        if not end_date:
            end_date = datetime.utcnow()
        
        params = {
            'lastModStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
            'lastModEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.000')
        }
        
        async with aiohttp.ClientSession(headers=self.headers) as session:
            try:
                async with session.get(self.nvd_base_url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return self._process_nvd_data(data)
                    else:
                        logger.error(f"Failed to fetch NVD data: {response.status}")
                        return []
            except Exception as e:
                logger.error(f"Error fetching NVD data: {e}")
                return []
    
    def _process_nvd_data(self, data: Dict) -> List[Dict]:
        """Process raw NVD API response into standardized format."""
        processed_cves = []
        
        for vuln in data.get('vulnerabilities', []):
            cve = vuln.get('cve', {})
            metrics = cve.get('metrics', {}).get('cvssMetricV31', [{}])[0].get('cvssData', {})
            
            processed_cve = {
                'cve_id': cve.get('id'),
                'title': cve.get('descriptions', [{}])[0].get('value'),
                'description': next((desc.get('value') for desc in cve.get('descriptions', [])
                                  if desc.get('lang') == 'en'), ''),
                'severity': metrics.get('baseSeverity'),
                'cvss_score': metrics.get('baseScore'),
                'cvss_vector': metrics.get('vectorString'),
                'published_date': cve.get('published'),
                'last_modified_date': cve.get('lastModified'),
                'affected_products': cve.get('configurations', []),
                'references': [ref.get('url') for ref in cve.get('references', [])],
                'metadata': {
                    'weaknesses': cve.get('weaknesses', []),
                    'vendorComments': cve.get('vendorComments', [])
                }
            }
            
            processed_cves.append(processed_cve)
        
        return processed_cves


class OWASPDataFetcher:
    """Service for fetching OWASP vulnerability data."""
    
    OWASP_TOP_10_2021 = {
        'A01:2021': {
            'title': 'Broken Access Control',
            'description': 'Access control enforces policy such that users cannot act outside of their intended permissions.',
            'controls': [
                'Implement proper access controls',
                'Use role-based access control (RBAC)',
                'Deny by default',
                'Implement proper session management'
            ]
        },
        'A02:2021': {
            'title': 'Cryptographic Failures',
            'description': 'Failures related to cryptography that often lead to exposure of sensitive data.',
            'controls': [
                'Encrypt all sensitive data at rest',
                'Use strong encryption algorithms',
                'Properly manage encryption keys',
                'Use secure protocols for data in transit'
            ]
        },
        # Add more OWASP Top 10 categories as needed
    }
    
    @classmethod
    def get_owasp_controls(cls) -> Dict:
        """Get OWASP Top 10 2021 controls and descriptions."""
        return cls.OWASP_TOP_10_2021


class CISDataFetcher:
    """Service for fetching CIS benchmark data."""
    
    # Example CIS controls - in production, this would be fetched from CIS API or files
    CIS_CONTROLS_V8 = {
        'CIS 1': {
            'title': 'Inventory and Control of Enterprise Assets',
            'description': 'Actively manage (inventory, track, and correct) all enterprise assets...',
            'controls': [
                'Establish and Maintain Detailed Enterprise Asset Inventory',
                'Address Unauthorized Assets',
                'Utilize an Active Discovery Tool'
            ]
        },
        'CIS 2': {
            'title': 'Inventory and Control of Software Assets',
            'description': 'Actively manage (inventory, track, and correct) all software...',
            'controls': [
                'Establish and Maintain a Software Inventory',
                'Ensure Authorized Software is Currently Supported',
                'Address Unauthorized Software'
            ]
        },
        # Add more CIS controls as needed
    }
    
    @classmethod
    def get_cis_controls(cls) -> Dict:
        """Get CIS Controls v8."""
        return cls.CIS_CONTROLS_V8